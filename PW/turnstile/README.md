<h4>Motivation</h4><div>pthread_mutex_t and std::mutex take up 40 bytes of memory. You could imagine a situation, where there are lots of mutexes and, hence, every byte counts.<br></div><p><br></p><p>"Turnstiles" are an example of how one can lower that memory footprint. This idea is used internally in NetBSD and Solaris among others. It hinges on the fact that a single thread cannot sleep on more than one mutex at a time. This fact allows all mutexes to be just placeholders. These placeholders are allocated a state (a "turnstile" in this terminology) on demand - when there is contention and one of the threads has to be suspended. The turnstile is held by the mutex until no more threads need to wait on it. This way, the total number of turnstiles used simultaneously is going to always be lower or equal to the number of threads. This allows for an implementation involving a global pool of turnstiles. A mutex grabs a turnstile from the pool when a thread needs to be suspended and releases the turnstile when no more threads need to sleep on this mutex.<br></p>You can find more detailed information about turnstiles online or you can figure it out yourself.<br><h4>The task</h4><div>Your task is to implement a "Mutex" class, which will take up no more then 8 bytes. It should implement the interface defined in "turnstile.h". The total memory consumption beyond the "Mutex" objects should not depend on the number of "Mutex" objects. It may depend on the number of threads, though.<br></div><div><br></div><div>You should not directly use futexes nor inline assembly. Please use std::mutex, std::condition_variable and std::atomic*.<br></div><h4>Technical requirements</h4><div>Solutions should be delivered in the form described below and should satisfy these requirements. Otherwise they will not be accepted.<br></div><ul><li>you should clone the git repository <a href="https://www.mimuw.edu.pl/~dopiera/turnstiles/">https://www.mimuw.edu.pl/~dopiera/turnstiles/</a></li><li>you should deliver the solution as the output of "git diff" against the tip of the master branch in that repository<br></li><li>"cmake . &amp;&amp; make" should compile the solution; a basic test is included in the repository<br></li><li>by default, cmake will configure compilation for debugging (no optimizations and extra assertions); in order to configure for performance, please run "cmake -DCMAKE_BUILD_TYPE=Release ."<br></li><li>if you add any files to the solution, please make sure "CMakeLists.txt" is updated too, so that "cmake . &amp;&amp; make" still builds the solution<br></li><li>you should not change the compilation flags in CMakeLists.txt nor the general structure of this file; the "tests" directory will be replaced for the purpose of testing your solution<br></li><li>the tests will include "turnstile.h" and link "trunstile_lib" - exactly like "trivial_test" does</li><li>you can and should modify "turnstile.h" - there are static assertions on requirements on the Mutex class in "trivial_test.cpp"<br></li><li>the solution should compile with g++ 7.3.0 and clang 6.0.0 on Ubuntu 18.04.1 LTS without any extra libraries (except pthreads)<br></li><li>compilation should not yield any warnings<br></li><li>the code should be formatted using the "scripts/format.sh" script<br></li><li>"scripts/tidy.sh" and "scripts/lint.sh" should not generate any warnings (you'll need "clang-tidy" for them to work)<br></li><li>the test from the aforementioned repository should continue to pass without any modifications<br></li><li>please use English for variable names, comments, functions, etc.<br></li></ul><div><h4>Environment</h4><div>The solution will be tested on Ubuntu. This section outlines how you can set up the envrionment for yourself.<br></div><div><br></div><div>In any Linux distribution please install docker. If you don't use Linux, you can install any distro in a VM.<br><br>Create a directory called "turnstile_tester". Inside it, create a "Dockerfile" file, with the following content:<br><pre>FROM ubuntu:18.04<br><br>RUN apt-get update &amp;&amp; apt-get install -y cmake clang g++ make clang \<br>    clang-tidy clang-format vim git</pre><br>In "turnstile_tester"''s parent directory run:<br><pre>$ docker build -t turnstile_tester turnstile_tester</pre><br>In order to switch to the environment , run:<br><pre>$ docker run -it -w /root -v "$(pwd):/root" turnstile_tester /bin/bash </pre></div></div><h4>Evaluation<br></h4><p>Correctness is going to be the most important factor. Solutions which limit the concurrency beyond what is necessary will be considered wrong. Performance and code quality will also be taken into account.<br></p><h3>FAQ</h3><div>This is where the most interesting questions and their answers will appear. Please send them to dopiera@mimuw.edu.pl.<br></div><p></p><ul><li>Can I assume that there will not be more than 2<sup>32</sup> Mutexes?</li></ul><div style="margin-left: 30px;" class="editor-indent">NO, let's assume that there can be as many as one can fit on a machine. On large machines 2<sup>32</sup> might be too few.<br></div><div style="margin-left: 30px;" class="editor-indent"><br></div><ul><li>Does the sentence "Solutions which limit the concurrency beyond what is necessary will be considered wrong." mean that there cannot be any global synchronization?<br></li></ul><div style="margin-left: 30px;" class="editor-indent">NO. The intention is such that this code doesn't block:<br></div><div style="margin-left: 30px;" class="editor-indent"><pre>Mutex m1, m2;<br>m1.lock();<br>m2.lock();<br>m2.unlock();<br>m1.unlock();<br></pre><p>You can have global, synchronized structures, but please be warned that global synchronization may be costly.</p></div><ul><li>Does the sentence "Please use std::mutex, std::condition_variable and std::atomic*" mean that one should not use "thread_local"</li></ul><div style="margin-left: 30px;" class="editor-indent">NO. You are allowed to use "thread_local". You are allowed to use any C++ features, but for synchronization, please limit yourself to the aforementioned.<br></div><ul><li>Does Mutex have to be fair?<br>NOT in a strict sense. Please don't make it too unfair, though, .e.g don't favor threads with lower thread ids.</li><li>Shall we ensure that unused "turnstile" objects are removed?<br><div>You should keep the invariant that there are not significantly more turnstiles than threads. If there are going to be fewer of them, it's even better, but please remember that performance will also be graded</div></li><li><div>How should one deliver the solution?</div></li></ul><div style="margin-left: 30px;" class="editor-indent">The aforementioned result of "git diff" against the tip of the master branch should be delivered via moodle in a file called "turnstile.diff".</div><ul><li>What pointer size should we assume?</li></ul><div style="margin-left: 30px;" class="editor-indent">64 bits.<br></div><ul><li>Can we assume that std::atomic&lt;&gt; has the same size as the type which it wraps?<br></li></ul><div style="margin-left: 30px;" class="editor-indent"><p>In general no, however for the purpose of thise exercise you can assume it's true for bool int8_t uint8_t int16_t uint16_t int32_t uint32_t int64_t uint64_t.</p></div><ul><li>How shall we handle improper use of Mutex?<br></li></ul><div style="margin-left: 30px;" class="editor-indent">Any way you wish - it won't be tested.<br></div><ul><li>How many turnstiles can coexist in a program? Assuming that N is the total number of threads, is it O(N), N+C or something else?</li></ul><div style="margin-left: 30px;" class="editor-indent">I'd prefer not to be precise with it. N+C seems to aggressive - I'wouldn't mind e.g. 2N. O(N) seems to relaxed, though, because it could mean 1000000N or N + 1000000000. Please use common sense. In real life both asymptotic complexity and the constants count.</div><ul><li>Why does the aforementioned list of type for which std::atomic size matches the size of underlying type doesn't include pointers?</li></ul><div style="margin-left: 30px;" class="editor-indent">It's an oversight. You can assume that std::atomic&lt;T*&gt; has the same size as T*.<br></div><div><br></div><div>Author: Marek Dopiera<br></div></span></span></div></div><div class="submissionstatustable">